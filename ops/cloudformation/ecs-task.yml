# For manual creation/update use:
# aws cloudformation deploy --stack-name ECS-task --template-file ecs-task.yml --capabilities CAPABILITY_IAM
AWSTemplateFormatVersion: '2010-09-09'

Description: Deploy a service on ECS, hosted in a private subnet, but accessible via a public load balancer.

Parameters:

  VPCStackName:
    Type: String
    Default: DevVPC
    Description: The name of the parent networking stack that you created. Necessary
                 to locate and reference resources created by that stack.
  ECSStackName:
    Type: String
    Default: ECS-cluster
    Description: The name of the parent ECS cluster stack.

  ALBStackName:
    Type: String
    Default: alb
    Description: The name of the connected ALB stack.

  Environment:
    Type: String
    Default: dev

  ServiceName:
    Type: String
    Default: dropwizard
    Description: A name for the service.

  BlueWeight:
    Type: String
    Default: 1
    Description: Green target group weight. 100% by default. This parameter is on canary deployment abidance.

  GreenWeight:
    Type: String
    Default: 0
    Description: Green target group weight. 0% by default. This parameter is on canary deployment abidance.


  ImageUrl:
    Type: String
#    Default: 054017840000.dkr.ecr.us-east-1.amazonaws.com/devopsa3:latest
    Default: 054017840000.dkr.ecr.us-east-1.amazonaws.com/snakes:latest
    Description: The url of a docker image that contains the application process that
                 will handle the traffic for this service

  ContainerPort:
    Type: Number
    Default: 8080
    Description: What port number the application inside the docker container is binding to

  ContainerCpu:
    Type: Number
    Default: 256
    Description: How much CPU to give the container. 1024 is 1 CPU

  ContainerMemory:
    Type: Number
    Default: 512
    Description: How much memory in megabytes to give the container

  Path:
    Type: String
    Default: "*"
    Description: A path on the public load balancer that this service
                 should be connected to. Use * to send all load balancer
                 traffic to this service.

  Priority:
    Type: Number
    Default: 2
    Description: The priority for the routing rule added to the load balancer.
                 This only applies if your have multiple services which have been
                 assigned to different paths on the load balancer.

  DesiredCount:
    Type: Number
    Default: 1
    Description: How many copies of the service task to run.

  MinCapacity:
    Type: Number
    Default: 1
    Description: How many copies of containers have to be run minimum.
    ConstraintDescription: Must be >= 1

  MaxCapacity:
    Type: Number
    Default: 10
    Description: How many copies of containers have to be run maximum.
    ConstraintDescription: Must be >= MinCapacity

  Role:
    Type: String
    Default: ""
    Description: (Optional) An IAM role to give the services containers if the code within needs to
                 access other AWS resources like S3 buckets, DynamoDB tables, etc

  DeploymentType:
    Type: String
    Default: "Blue"
    Description: Must be Blue or Green, depends on the situation. If there is already Blue stack,
                   and you are going to deploy new version - use Green here.
    AllowedValues: [ 'Blue','Green' ]

Conditions:

  HasCustomRole: !Not [ !Equals [!Ref 'Role', ''] ]
  IsDeploymentBlue: [ !Equals [!Ref 'Blue', ''] ]

Resources:

  # The task definition. This is a simple metadata description of what
  # container to run, and what resource requirements it has.
  TaskDefinition:
    Type: AWS::ECS::TaskDefinition
    Properties:
      Family: !Ref 'ServiceName'
      Cpu: !Ref 'ContainerCpu'
      Memory: !Ref 'ContainerMemory'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - EC2
      ExecutionRoleArn:
        Fn::ImportValue: !Sub "${ECSStackName}:ECSTaskExecutionRole"
      TaskRoleArn:
        Fn::If:
          - 'HasCustomRole'
          - !Ref 'Role'
          - !Ref "AWS::NoValue"
      ContainerDefinitions:
        - Name: !Ref 'ServiceName'
          Cpu: !Ref 'ContainerCpu'
          Memory: !Ref 'ContainerMemory'
          Image: !Ref 'ImageUrl'
          PortMappings:
            - ContainerPort: !Ref 'ContainerPort'

  # The service. The service is a resource which allows you to run multiple
  # copies of a type of task, and gather up their logs and metrics, as well
  # as monitor the number of running tasks and replace any that have crashed
  Service:
    Type: AWS::ECS::Service
    DependsOn: LoadBalancerRule
    Properties:
      ServiceName: !Ref 'ServiceName'
      Cluster:
        Fn::ImportValue: !Sub "${ECSStackName}:ClusterName"
      DeploymentConfiguration:
        MaximumPercent: 200
        MinimumHealthyPercent: 75
      DesiredCount: !Ref 'DesiredCount'
      NetworkConfiguration:
        AwsvpcConfiguration:
          SecurityGroups:
            - Fn::ImportValue: !Sub "${ECSStackName}:EcsHostSecurityGroup"
          Subnets:
            - Fn::ImportValue: !Sub "${VPCStackName}-PrivateSubnet0"
            - Fn::ImportValue: !Sub "${VPCStackName}-PrivateSubnet1"
      TaskDefinition: !Ref 'TaskDefinition'
      LoadBalancers:
        - ContainerName: !Ref 'ServiceName'
          ContainerPort: !Ref 'ContainerPort'
          TargetGroupArn:
            Fn::If:
              - 'IsDeploymentBlue'
              - !Ref 'TargetGroupBlue'
              - !Ref 'TargetGroupGreen'

  ScalableTargetRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: 'application-autoscaling.amazonaws.com'
          Action: 'sts:AssumeRole'
      Path: '/'
      Policies:
      - PolicyName: ecs
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - 'ecs:DescribeServices'
            - 'ecs:UpdateService'
            Resource: '*'
      - PolicyName: cloudwatch
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - 'cloudwatch:DescribeAlarms'
            Resource: '*'

  ScalableTarget:
    Type: 'AWS::ApplicationAutoScaling::ScalableTarget'
    Properties:
      MinCapacity: !Ref MinCapacity
      MaxCapacity: !Ref MaxCapacity
      ResourceId: !Sub
      - 'service/${Cluster}/${Service}'
      - Cluster:
          Fn::ImportValue: !Sub "${ECSStackName}:ClusterName"
        Service: !GetAtt 'Service.Name'
      RoleARN: !GetAtt 'ScalableTargetRole.Arn'
      ScalableDimension: 'ecs:service:DesiredCount'
      ServiceNamespace: ecs

  ScalePolicy:
    Type: 'AWS::ApplicationAutoScaling::ScalingPolicy'
    Properties:
      PolicyName: !Sub '${AWS::StackName}-scalepolicy'
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref ScalableTarget
      TargetTrackingScalingPolicyConfiguration:
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization
        ScaleInCooldown: 5
        ScaleOutCooldown: 5
        TargetValue: 60

  # A target group. This is used for keeping track of all the tasks, and
  # what IP addresses / port numbers they have. You can query it yourself,
  # to use the addresses yourself, but most often this target group is just
  # connected to an application load balancer, or network load balancer, so
  # it can automatically distribute traffic across all the targets.
  TargetGroupBlue:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Condition: IsDeploymentBlue
    Properties:
      HealthCheckIntervalSeconds: 11
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      TargetType: ip
      Matcher:
        HttpCode: '200-499'
      Name: !Ref 'ServiceName'
      Port: !Ref 'ContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue: !Sub "${VPCStackName}-VPCId"
      Tags:
      - Key: 'Name'
        Value: !Sub 'tg${AWS::StackName}'
      - Key: 'Environment'
        Value: !Ref Environment

  TargetGroupGreen:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Condition: IsDeploymentBlue
    Properties:
      HealthCheckIntervalSeconds: 11
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 10
      HealthyThresholdCount: 2
      TargetType: ip
      Matcher:
        HttpCode: '200-299'
      Name: !Ref 'ServiceName'
      Port: !Ref 'ContainerPort'
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      VpcId:
        Fn::ImportValue: !Sub "${VPCStackName}-VPCId"

    HttpListener:
      Type: AWS::ElasticLoadBalancingV2::Listener
      Condition: IsDeploymentBlue
      Properties:
        DefaultActions:
          - Type: redirect
            RedirectConfig:
              Protocol: HTTPS
              Port: '443'
              StatusCode: HTTP_301
        LoadBalancerArn:
          Fn::ImportValue: !Sub "${ALBStackName}:-ALB-ARN"
        Port: 80
        Protocol: HTTP

    HttpsListener:
      Type: 'AWS::ElasticLoadBalancingV2::Listener'
      Condition: IsDeploymentBlue
      Properties:
        Certificates:
          - CertificateArn: !Ref SSLCertificateARN
        DefaultActions:
          - Type: forward
           ForwardConfig:
             TargetGroups:
             - TargetGroupArn: !Ref TargetGroup
               Weight: !Ref BlueWeight
             - TargetGroupArn: !Ref TargetGroupGreen
               Weight: !GreenWeight
             TargetGroupStickinessConfig:
               Enabled: true
               DurationSeconds: 2000
        LoadBalancerArn:
          Fn::ImportValue: !Sub "${ALBStackName}:-ALB-ARN"
        Port: 443
        Protocol: HTTPS

  # Create a rule on the load balancer for routing traffic to the target group
  LoadBalancerRule:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
         - Type: 'forward'
      Conditions:
        - Field: path-pattern
          Values: [!Ref 'Path']
      ListenerArn: !Ref HttpsListener
      Priority: !Ref 'Priority'

  Outputs:

    TargetGroupBlue:
      Description: 'ARN of the blue target group'
      Value: !Ref TargetGroup
      Export:
        Type: String
        Name: 'BlueTargetGroup-ARN'

    TargetGroupGreen:
      Description: 'ARN of the green target group'
      Value: !Ref TargetGroupGreen
      Export:
        Type: String
        Name: 'GreenTargetGroup-ARN'
